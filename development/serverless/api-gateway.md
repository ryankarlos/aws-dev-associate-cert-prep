

Amazon API Gateway is an AWS service for creating, publishing, maintaining, monitoring, and securing REST, HTTP, and WebSocket APIs at any scale. 
API developers can create APIs that access AWS or other web services, as well as data stored in the AWS Cloud. 
As an API Gateway API developer, you can create APIs for use in your own client applications. 
Or you can make your APIs available to third-party app developers. .

API Gateway creates RESTful APIs that:

* Are HTTP-based.
* Enable stateless client-server communication.
* Implement standard HTTP methods such as GET, POST, PUT, PATCH, and DELETE.

REST APIs and HTTP APIs are both RESTful API products. REST APIs support more features than HTTP APIs, 
while HTTP APIs are designed with minimal features so that they can be offered at a lower price. Choose REST APIs if 
you need features such as API keys, per-client throttling, request validation, AWS WAF integration, or private API endpoints. 
Choose HTTP APIs if you don't need the features included with REST APIs.


API Gateway creates WebSocket APIs that:

* Adhere to the WebSocket protocol, which enables stateful, full-duplex communication between client and server.
* Route incoming messages based on message content.


## RestAPI with Lambda Integration

To build an API with Lambda integrations, you can use Lambda proxy integration or Lambda non-proxy integration.

In Lambda proxy integration, the input to the integrated Lambda function can be expressed as any combination of request headers, 
path variables, query string parameters, and body. In addition, the Lambda function can use API configuration settings to 
influence its execution logic. For an API developer, setting up a Lambda proxy integration is simple. Other than 
choosing a particular Lambda function in a given region, you have little else to do. API Gateway configures the 
integration request and integration response for you. Once set up, the integrated API method can evolve with the backend without
modifying the existing settings. This is possible because the backend Lambda function developer parses the incoming request data 
and responds with desired results to the client when nothing goes wrong or responds with error messages when anything goes wrong.

In Lambda non-proxy integration, you must ensure that input to the Lambda function is supplied as the integration request 
payload. This implies that you, as an API developer, must map any input data the client supplied as request parameters 
into the proper integration request body. You may also need to translate the client-supplied request body into a 
format recognized by the Lambda function.


## Rest API with HTTP integratiomn

To build an API with HTTP integration, you can use either the HTTP proxy integration or the HTTP custom integration. 
We recommend that you use the HTTP proxy integration, whenever possible, for the streamlined API set up while providing 
versatile and powerful features. The HTTP custom integration can be compelling if it is necessary to transform client 
request data for the backend or transform the backend response data for the client.

## Set up 


**API resources**

In an API Gateway API, you expose addressable resources as a tree of API Resources entities, with the root resource (/) at the top of the hierarchy. The root resource is relative to the API's base URL, which consists of the API endpoint and a stage name. In the API Gateway console, this base URI is referred to as the Invoke URI and is displayed in the API's stage editor after the API is deployed.

The API endpoint can be a default host name or a custom domain name. The default host name is of the following format:

```
{api-id}.execute-api.{region}.amazonaws.com
```
In this format, the {api-id} represents the API identifier that is generated by API Gateway. The {region} variable represents the AWS Region (for example, us-east-1) that you chose when creating the API. A custom domain name is any user-friendly name under a valid internet domain. For example, if you have registered an internet domain of example.com, any of *.example.com is a valid custom domain name. For more information, see create a custom domain name.

For the PetStore sample API, the root resource (/) exposes the pet store. The /pets resource represents the collection of pets available in the pet store. The /pets/{petId} exposes an individual pet of a given identifier (petId). The path parameter of {petId} is part of the request parameters.

To set up an API resource, you choose an existing resource as its parent and then create the child resource under this parent resource. You start with the root resource as a parent, add a resource to this parent, add another resource to this child resource as the new parent, and so on, to its parent identifier. Then you add the named resource to the parent.


**Method request**

An API method request is encapsulated by the API Gateway Method resource. To set up the method request, you must first instantiate the Method resource, setting at least an HTTP method and an authorization type on the method.

Closely associated with the proxy resource, API Gateway supports an HTTP method of ANY. This ANY method represents any HTTP method that is to be supplied at run time. It allows you to use a single API method setup for all of the supported HTTP methods of DELETE, GET, HEAD, OPTIONS, PATCH, POST, and PUT.

You can set up the ANY method on a non-proxy resource as well. Combining the ANY method with a proxy resource, you get a single API method setup for all of the supported HTTP methods against any resources of an API. Furthermore, the backend can evolve without breaking the existing API setup.

Before setting up an API method, consider who can call the method. Set the authorization type according to your plan. For open access, set it to NONE. To use IAM permissions, set the authorization type to AWS_IAM. To use a Lambda authorizer function, set this property to CUSTOM. To use an Amazon Cognito user pool, set the authorization type to COGNITO_USER_POOLS.


**Request Parameters**

Method request parameters are a way for a client to provide input data or execution context necessary to complete the method request. A method parameter can be a path parameter, a header, or a query string parameter. As part of method request setup, you must declare required request parameters to make them available for the client. For non-proxy integration, you can translate these request parameters to a form that is compatible with the backend requirement.
For example, for the GET /pets/{petId} method request, the {petId} path variable is a required request parameter. You can declare this path parameter when calling the put-method command of the AWS CLI.

**Request Model**

For an API method that can take input data in a payload, you can use a model. A model is expressed in a JSON schema draft 4 and describes the data structure of the request body. With a model, a client can determine how to construct a method request payload as input. More importantly, API Gateway uses the model to validate a request, generate an SDK, and initialize a mapping template for setting up the integration in the API Gateway console.

**Integrations**

After setting up an API method, you must integrate it with an endpoint in the backend. A backend endpoint is also referred
to as an integration endpoint and can be a Lambda function, an HTTP webpage, or an AWS service action.

As with the API method, the API integration has an integration request and an integration response. An integration request 
encapsulates an HTTP request received by the backend. It might or might not differ from the method request submitted by the 
client. An integration response is an HTTP response encapsulating the output returned by the backend.

Setting up an integration request involves the following: configuring how to pass client-submitted method requests to the 
backend; configuring how to transform the request data, if necessary, to the integration request data; and specifying which 
Lambda function to call, specifying which HTTP server to forward the incoming request to, or specifying the AWS service 
action to invoke.

Setting up an integration response (applicable to non-proxy integrations only) involves the following: configuring how to 
pass the backend-returned result to a method response of a given status code, configuring how to transform specified 
integration response parameters to preconfigured method response parameters, and configuring how to map the integration 
response body to the method response body according to the specified body-mapping templates.

Programmatically, an integration request is encapsulated by the Integration resource and an integration response by the 
IntegrationResponse resource of API Gateway.

To set up an integration request, you create an Integration resource and use it to configure the integration endpoint URL. 
You then set the IAM permissions to access the backend, and specify mappings to transform the incoming request data before passing it to the backend. To set up an integration response for non-proxy integration, you create an IntegrationResponse resource and use it to set its target method response. You then configure how to map backend output to the method response.


**Authorization**

API Gateway supports multiple mechanisms for controlling and managing access to your API. 
To control who can call the API method, you can configure the authorization type on the method. You can use this type to enact one of the 
supported authorizers, including IAM roles and policies (AWS_IAM), an Amazon Cognito user pool (COGNITO_USER_POOLS), or a Lambda authorizer (CUSTOM). 
To use IAM permissions to authorize access to the API method, set the authorization-type input property to AWS_IAM. When this option is set, 
API Gateway verifies the caller's signature on the request, based on the caller's IAM user's access key identifier and secret key. 
If the verified user has permission to call the method, the request is accepted. Otherwise, the request is rejected and the caller 
receives an unauthorized error response. The call to the method does not succeed unless the caller has been granted permission to invoke the 
API method or if the caller is allowed to assume a role that has been granted the permission. 

**Method response**

An API method response encapsulates the output of an API method request that the client will receive. The output data includes an HTTP status code, some headers, and possibly a body.

With non-proxy integrations, the specified response parameters and body can be mapped from the associated integration response data or can be assigned certain static values according to mappings. These mappings are specified in the integration response. The mapping can be an identical transformation that passes the integration response through as-is.
With a proxy integration, API Gateway passes the backend response through to the method response automatically. There is no need for you to set up the API method response. However, with the Lambda proxy integration, the Lambda function must return a result of this output format for API Gateway to successfully map the integration response to a method response.

Programmatically, the method response setup amounts to creating a MethodResponse resource of API Gateway and setting the properties of statusCode, responseParameters, and responseModels.
When setting status codes for an API method, you should choose one as the default to handle any integration response of an unanticipated status code. It is reasonable to set 500 as the default because this amounts to casting otherwise unmapped responses as a server-side error. For instructional reasons, the API Gateway console sets the 200 response as the default. But you can reset it to the 500 response.

## Integration Types 

You choose an API integration type according to the types of integration endpoint you work with and how you want data to 
pass to and from the integration endpoint. For a Lambda function, you can have the Lambda proxy integration, or the 
Lambda custom integration. For an HTTP endpoint, you can have the HTTP proxy integration or the HTTP custom integration. 
For an AWS service action, you have the AWS integration of the non-proxy type only. API Gateway also supports the
mock integration, where API Gateway serves as an integration endpoint to respond to a method request.

The Lambda custom integration is a special case of the AWS integration, where the integration endpoint corresponds to the 
function-invoking action of the Lambda service.

Programmatically, you choose an integration type by setting the type property on the Integration resource. 
For the Lambda proxy integration, the value is AWS_PROXY. For the Lambda custom integration and all other 
AWS integrations, it is AWS. For the HTTP proxy integration and HTTP integration, the value is HTTP_PROXY and 
HTTP, respectively. For the mock integration, the type value is MOCK.

The Lambda proxy integration supports a streamlined integration setup with a single Lambda function. The setup is 
simple and can evolve with the backend without having to tear down the existing setup. For these reasons, it is highly 
recommended for integration with a Lambda function.

In contrast, the Lambda custom integration allows for reuse of configured mapping templates for various integration 
endpoints that have similar requirements of the input and output data formats. The setup is more involved and is 
recommended for more advanced application scenarios.

Similarly, the HTTP proxy integration has a streamlined integration setup and can evolve with the backend without 
having to tear down the existing setup. The HTTP custom integration is more involved to set up, but allows for 
reuse of configured mapping templates for other integration endpoints.

The following list summarizes the supported integration types:

* AWS: This type of integration lets an API expose AWS service actions. In AWS integration, you must configure both the 
  integration request and integration response and set up necessary data mappings from the method request to the integration
  request, and from the integration response to the method response.
* AWS_PROXY: This type of integration lets an API method be integrated with the Lambda function invocation action with a 
  flexible, versatile, and streamlined integration setup. This integration relies on direct interactions between the client
  and the integrated Lambda function. 
  With this type of integration, also known as the Lambda proxy integration, you do not set the integration request or the
  integration response. API Gateway passes the incoming request from the client as the input to the backend Lambda function.
  The integrated Lambda function takes
  the input of this format and parses the input from all available sources, including request headers, URL path variables,
  query string parameters, and applicable body. The function returns the result following this output format. 
  This is the preferred integration type to call a Lambda function through API Gateway and is not applicable to any other 
  AWS service actions, including Lambda actions other than the function-invoking action.
* HTTP: This type of integration lets an API expose HTTP endpoints in the backend. With the HTTP integration, also known 
  as the HTTP custom integration, you must configure both the integration request and integration response. You must set 
  up necessary data mappings from the method request to the integration request, and from the integration response to the
  method response.
* HTTP_PROXY: The HTTP proxy integration allows a client to access the backend HTTP endpoints with a streamlined integration
  setup on single API method. You do not set the integration request or the integration response. API Gateway passes the 
  incoming request from the client to the HTTP endpoint and passes the outgoing response from the HTTP endpoint to the client.
* MOCK: This type of integration lets API Gateway return a response without sending the request further to the backend. 
  This is useful for API testing because it can be used to test the integration set up without incurring charges for using 
  the backend and to enable collaborative development of an API.

## Monitoring

* API Gateway console is integrated with CloudWatch, so you get backend performance metrics such as API calls, 
latency, and error rates. 
* You can set up custom alarms on API Gateway APIs.
* API Gateway can also log API execution errors to CloudWatch Logs.


## Authorization 

**IAM permissions**

You control access to your Amazon API Gateway API with IAM permissions by controlling access to the following two 
API Gateway component processes:

* To create, deploy, and manage an API in API Gateway, you must grant the API developer permissions to perform the
  required actions supported by the API management component of API Gateway.
* To call a deployed API or to refresh the API caching, you must grant the API caller permissions to perform required 
  IAM actions supported by the API execution component of API Gateway.

To allow an API caller to invoke the API or refresh its caching, you must create IAM policies that permit a specified 
API caller to invoke the API method for which the IAM user authentication is enabled. The API developer sets the method's
authorizationType property to AWS_IAM to require that the caller submit the IAM user's access keys to be authenticated.
Then, you attach the policy to an IAM user representing the API caller, to an IAM group containing the user, or to an IAM 
role assumed by the user.


**Lambda Authorizer**

A Lambda authorizer (formerly known as a custom authorizer) is an API Gateway feature that uses a Lambda function to
control access to your API.
A Lambda authorizer is useful if you want to implement a custom authorization scheme that uses a bearer token 
authentication strategy such as OAuth or SAML, or that uses request parameters to determine the caller's identity.

When a client makes a request to one of your API's methods, API Gateway calls your Lambda authorizer, which takes 
the caller's identity as input and returns an IAM policy as output.

There are two types of Lambda authorizers:
* A token-based Lambda authorizer (also called a TOKEN authorizer) receives the caller's identity in a bearer token, such as a JSON Web Token (JWT) or an OAuth token. For an example application, see Open Banking Brazil - Authorization Samples on GitHub.
* A request parameter-based Lambda authorizer (also called a REQUEST authorizer) receives the caller's identity in a combination of headers, query string parameters, stageVariables, and $context variables.
* For WebSocket APIs, only request parameter-based authorizers are supported.

Lambda authorizer workflow: 

* The client calls a method on an API Gateway API method, passing a bearer token or request parameters.
* API Gateway checks whether a Lambda authorizer is configured for the method. If it is, API Gateway calls the Lambda function.
* The Lambda function authenticates the caller by means such as the following:
* Calling out to an OAuth provider to get an OAuth access token.
* Calling out to a SAML provider to get a SAML assertion.
* Generating an IAM policy based on the request parameter values.
* Retrieving credentials from a database.
If the call succeeds, the Lambda function grants access by returning an output object containing at least an IAM policy and a principal identifier.
* API Gateway evaluates the policy.
    1. If access is denied, API Gateway returns a suitable HTTP status code, such as 403 ACCESS_DENIED.
    2. If access is allowed, API Gateway executes the method. If caching is enabled in the authorizer settings, API Gateway also caches the policy so that the Lambda authorizer function doesn't need to be invoked again.
    
**Cognito user pool**

As an alternative to using IAM roles and policies or Lambda authorizers (formerly known as custom authorizers), you can use an 
Amazon Cognito user pool to control who can access your API in Amazon API Gateway.

To use an Amazon Cognito user pool with your API, you must first create an authorizer of the COGNITO_USER_POOLS type and 
then configure an API method to use that authorizer. After the API is deployed, the client must first sign the user in 
to the user pool, obtain an identity or access token for the user, and then call the API method with one of the tokens, 
which are typically set to the request's Authorization header. The API call succeeds only if the required token is supplied
and the supplied token is valid, otherwise, the client isn't authorized to make the call because the client did not have 
credentials that could be authorized.

The identity token is used to authorize API calls based on identity claims of the signed-in user. The access token is used 
to authorize API calls based on the custom scopes of specified access-protected resources.

To create and configure an Amazon Cognito user pool for your API, you perform the following tasks:

* Use the Amazon Cognito console, CLI/SDK, or API to create a user pool—or use one that's owned by another AWS account.
* Use the API Gateway console, CLI/SDK, or API to create an API Gateway authorizer with the chosen user pool.
* Use the API Gateway console, CLI/SDK, or API to enable the authorizer on selected API methods.

To call any API methods with a user pool enabled, your API clients perform the following tasks:

* Use the Amazon Cognito CLI/SDK or API to sign a user in to the chosen user pool, and obtain an identity token or access token.
* Use a client-specific framework to call the deployed API Gateway API and supply the appropriate token in the Authorization header.

As the API developer, you must provide your client developers with the user pool ID, a client ID, and possibly the associated
client secrets that are defined as part of the user pool.

## Caching 

You can enable API caching in Amazon API Gateway to cache your endpoint's responses. With caching, you can reduce the 
number of calls made to your endpoint and also improve the latency of requests to your API.

When you enable caching for a stage, API Gateway caches responses from your endpoint for a specified time-to-live 
(TTL) period, in seconds. API Gateway then responds to the request by looking up the endpoint response from the cache 
instead of making a request to your endpoint. The default TTL value for API caching is 300 seconds. The maximum TTL 
value is 3600 seconds. TTL=0 means caching is disabled. When you enable caching within a stage's Cache Settings, 
only GET methods are cached. 
Caching is best-effort. You can use the CacheHitCount and CacheMissCount metrics in Amazon CloudWatch to monitor requests 
that API Gateway serves from the API cache. The maximum size of a response that can be cached is 1048576 bytes. 
Cache data encryption may increase the size of the response when it is being cached.

You can override stage-level cache settings by enabling or disabling caching for a specific method. By increasing or 
decreasing its TTL period; or by turning encryption on or off for cached responses.

A client of your API can invalidate an existing cache entry and reload it from the integration endpoint for individual
requests. The client must send a request that contains the Cache-Control: max-age=0 header. The client receives
the response directly from the integration endpoint instead of the cache, provided that the client is authorized to 
do so. This replaces the existing cache entry with the new response, which is fetched from the integration endpoint.

If you don't impose an InvalidateCache policy (or choose the Require authorization check box in the console), any client can
invalidate the API cache. If most or all of the clients invalidate the API cache, this could significantly increase 
the latency of your API.
When the policy is in place, caching is enabled and authorization is required. You can control how unauthorized requests
are handled by choosing an option from Handle unauthorized requests in the API Gateway console.

The three options result in the following behaviors:

* Fail the request with 403 status code: returns a 403 Unauthorized response. 
  To set this option using the API, use FAIL_WITH_403.

* Ignore cache control header; Add a warning in response header: process the request and add a warning header in the response. 
  To set this option using the API, use SUCCEED_WITH_RESPONSE_HEADER.

* Ignore cache control header: process the request and do not add a warning header in the response. 
  To set this option using the API, use SUCCEED_WITHOUT_RESPONSE_HEADER.

  
## Security

To authorize and verify API requests to AWS services, API Gateway can help you leverage signature version 4. 
Using signature version 4 authentication, you can use IAM and access policies to authorize access to your APIs 
and all your other AWS resources.
You can enable AWS WAF for your APIs in Amazon API Gateway, making it easier to protect your APIs 
against common web exploits such as SQL injection and Cross-Site Scripting (XSS).
For API Gateway HTTP APIs, in addition to the previously supported OIDC/OAuth2 authorization option, you 
can also secure them using Lambda authorizers and IAM authorizers.

If you choose to enable caching for a REST API, you can enable cache encryption (for encryption at rest).

The APIs created with Amazon API Gateway expose HTTPS endpoints only. API Gateway doesn't support 
unencrypted (HTTP) endpoints. For greater security, you can choose a minimum Transport Layer Security (TLS) protocol version to be enforced for 
your API Gateway custom domain. You can choose either a TLS version 1.2 or TLS version 1.0 security policy. 
WebSocket APIs and HTTP APIs support only TLS 1.2. To learn more, see Choosing a minimum TLS version for a custom 
domain in API Gateway.
You can also set up a Amazon CloudFront distribution with a custom SSL certificate in your account and use it with 
Regional APIs. You can then configure the security policy for the CloudFront distribution with TLS 1.1 or higher based on 
your security and compliance requirements.

